[TOC]

1、目前是怎么样存储数据的？弊端是什么

- 在内存中存储的数据是用来处理、修改、运算的，不能长久保存。

2、计算机中，有没有一块硬件可以永久存储数据的？

- 磁盘中数据的形式就是文件，文件是数据的载体。

**思路：**

1、先要定位文件

- File类可以定位文件：进行删除、获取文本本身信息等操作。
- 但是不能读写文件内容。

2、读写文件数据

- IO流技术可以对硬盘中的文件进行读写

3、今日总体学习思路

- 先学会使用File类定位文件以及操作文件本身
- 然后学习IO流读写文件数据。

# File类概述

- File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹）。
- File类提供了诸如：定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能。
- **但是不能读写文件内容。**

**File类创建对象**

| 方法名称                                     | 说明                                               |
| -------------------------------------------- | -------------------------------------------------- |
| **public** File(String pathname)             | 根据文件路径创建文件对象                           |
| **public** File(String parent, String child) | 从父路径名字符串和子路径名字符串创建文件对象       |
| **public** File(File parent, String child)   | 根据父路径对应文件对象和子路径名字符串创建文件对象 |

- File对象可以定位文件和文件夹
- File封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。

**绝对路径和相对路径**

- 绝对路径：从盘符开始

  ```
  File file1 = new File(“D:\\itheima\\a.txt”);
  ```

- 相对路径：不带盘符，默认直接到当前工程下的目录寻找文件。

  ```
  File file3 = new File(“模块名\\a.txt”); 
  ```



## File类的常用API

**File类的判断文件类型、获取文件信息功能**

| 方法名称                        | 说明                                       |
| ------------------------------- | ------------------------------------------ |
| public boolean isDirectory()    | 测试此抽象路径名表示的File是否为文件夹     |
| public boolean isFile()         | 测试此抽象路径名表示的File是否为文件       |
| public boolean exists()         | 测试此抽象路径名表示的File是否存在         |
| public String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串         |
| public String getPath()         | 将此抽象路径名转换为路径名字符串           |
| public String getName()         | 返回由此抽象路径名表示的文件或文件夹的名称 |
| public long lastModified()      | 返回文件最后修改的时间毫秒值               |

**创建文件、删除文件功能**

File类创建文件的功能

| 方法名称                       | 说明                 |
| ------------------------------ | -------------------- |
| public boolean createNewFile() | 创建一个新的空的文件 |
| public boolean mkdir()         | 只能创建一级文件夹   |
| public boolean mkdirs()        | 可以创建多级文件夹   |

File类删除文件的功能

| 方法名称                | 说明                                   |
| ----------------------- | -------------------------------------- |
| public boolean delete() | 删除由此抽象路径名表示的文件或空文件夹 |

- delete方法默认只能删除文件和空文件夹。默认不能删除非空文件夹。
- delete方法直接删除不走回收站

**遍历文件夹**

File类的遍历功能

| 方法名称                        | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public String[] list()          | 获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。 |
| public File[] listFiles()(常用) | 获取当前目录下所有的"一级文件对象"到一个文件对象数组中去返回（重点） |

listFiles方法注意事项：

1. 当调用者不存在时，返回null
2. 当调用者是一个文件时，返回null
3. 当调用者是一个空文件夹时，返回一个长度为0的数组
4. 当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回
5. 当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容
6. 当调用者是一个需要权限才能进入的文件夹时，返回null



# 方法递归的应用

**文件搜索**

分析：

1. 先定位出的应该是一级文件对象
2. 遍历全部一级文件对象，判断是否是文件
3. 如果是文件，判断是否是自己想要的
4. 如果是文件夹，需要继续递归进去重复上述过程

**删除非空文件夹**

分析：

1. File默认不可以删除非空文件夹
2. 我们需要遍历文件夹，先删除里面的内容，再删除自己。

**拷贝文件**

将某个磁盘的文件夹拷贝到另一个文件夹下去，包括文件夹中的全部信息

分析：

1. IO默认不可以拷贝文件夹
2. 我们需要遍历文件夹，如果是文件则拷贝过去，如果是文件夹则要进行1-1创建，再递归。



# 字符集

## 常见字符集介绍

计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是**字符集**

**SCII字符集：**

- ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)：包括了数字、英文、符号。
-  ASCII使用1个字节存储一个字符，一个字节是8位，总共可以表示128个字符信息，对于英文，数字来说是够用的。

```
01100001‬ = 97  => a
‭01100010‬ = 98  => b
```

**GBK：**

- window系统默认的码表。兼容ASCII码表，也包含了几万个汉字，并支持繁体汉字以及部分日韩文字。
- **注意**：GBK是中国的码表，**一个中文以两个字节的形式存储**。但不包含世界上所有国家的文字。

**Unicode码表：**

-  unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界字符编码标准。
- 容纳世界上大多数国家的所有常见文字和符号。
- 由于Unicode会先通过UTF-8，UTF-16，以及 UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。

**注意：**

1. Unicode是万国码，以UTF-8编码后一个**中文一般以三个字节的形式存储。**
2. UTF-8也要兼容ASCII编码表。
3. 技术人员都应该使用UTF-8的字符集编码。
4. 编码前和编码后的字符集需要一致，否则会出现中文乱码。

<img src="image\utf-8.png" alt="汉字存储和展示过程解析" />

1. 字符串常见的字符底层组成是什么样的？

- 英文和数字等在任何国家的字符集中都占1个字节
- GBK字符中一个中文字符占2个字节
- UTF-8编码中一个中文1般占3个字节

2. 编码前的字符集和编码好的字符集有什么要求？

- 必须一致，否则会出现中文字符乱码
- 英文和数字在任何国家的编码中都不会乱码



## 字符集的编码、解码操作

**String编码**

| 方法名称                            | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| byte[] getBytes()                   | 使用平台的默认字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 |
| byte[] getBytes(String charsetName) | 使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 |

String解码

| 构造器           | 说明               |
| -------- | ----------------------- |
| String(byte[] bytes)  | 通过使用平台的默认字符集解码指定的字节数组来构造新的 String |
| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的 String         |



# IO流概述

IO流也称为输入、输出流，就是用来读写数据的。

IO流概述

- I表示intput，是数据从硬盘文件读入到内存的过程，称之输入，负责读。
- O表示output，是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。

<img src="D:\桌面文件\笔记\notes\java-base\image\IO分类.png" alt="IO流分类" style="zoom:90%;" />

**总结流的四大类:**

- 字节输入流：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输入流。
- 字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。
- 字符输入流：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。
- 字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。



# 字节流的使用

![IO流体系](image\IO体系.png)

## 文件字节输入流

1. **每次读取一个字节**

   文件字节输入流：FileInputStream

   作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。

   | 构造器                                  | 说明                               |
   | --------------------------------------- | ---------------------------------- |
   | public FileInputStream(File file)       | 创建字节输入流管道与源文件对象接通 |
   | public FileInputStream(String pathname) | 创建字节输入流管道与源文件路径接通 |

   | 方法名称                       | 说明                                                   |
   | ------------------------------ | ------------------------------------------------------ |
   | public int read()              | 每次读取一个字节返回，如果字节已经没有可读的返回-1     |
   | public int read(byte[] buffer) | 每次读取一个字节数组返回，如果字节已经没有可读的返回-1 |

   **每次读取一个字节存在什么问题？**

   - 性能较慢
   - 读取中文字符输出无法避免乱码问题。

​		

2. **每次读取一个字节数组**

   文件字节输入流：FileInputStream

   作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。

   | 方法名称                       | 说明                                                   |
   | ------------------------------ | ------------------------------------------------------ |
   | public int read()              | 每次读取一个字节返回，如果字节已经没有可读的返回-1     |
   | public int read(byte[] buffer) | 每次读取一个字节数组返回，如果字节已经没有可读的返回-1 |

   **每次读取一个字节数组存在什么问题？**

   - 读取的性能得到了提升
   - 读取中文字符输出无法避免乱码问题。



3. **一次读完全部字节**

   1. 如何使用字节输入流读取中文内容输出不乱码呢？

      定义一个与文件一样大的字节数组，一次性读取完文件的全部字节。

   2. 直接把文件数据全部读取到一个字节数组可以避免乱码，是否存在问题？

      如果文件过大，字节数组可能引起内存溢出。

   **方式一**
    自己定义一个字节数组与文件的大小一样大，然后使用读取字节数组的方法，一次性读取完成

   | 方法名称                       | 说明                                                   |
   | ------------------------------ | ------------------------------------------------------ |
   | public int read(byte[] buffer) | 每次读取一个字节数组返回，如果字节已经没有可读的返回-1 |

   **方式二**
    官方为字节输入流InputStream提供了如下API可以直接把文件的全部数据读取到一个字节数组中

   | 方法名称                                        | 说明                                                         |
   | ----------------------------------------------- | ------------------------------------------------------------ |
   | public byte[] readAllBytes() throws IOException | 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 |





## 文件字节输出流

1. 写字节数据到文件

   文件字节输出流：FileOutputStream
   作用：以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。

   | 构造器                                                   | 说明                                           |
   | -------------------------------------------------------- | ---------------------------------------------- |
   | public FileOutputStream(File file)                       | 创建字节输出流管道与源文件对象接通             |
   | public FileOutputStream(File file，boolean append)       | 创建字节输出流管道与源文件对象接通，可追加数据 |
   | public FileOutputStream(String filepath)                 | 创建字节输出流管道与源文件路径接通             |
   | public FileOutputStream(String filepath，boolean append) | 创建字节输出流管道与源文件路径接通，可追加数据 |

   **文件字节输出流（FileOutputStream）写数据出去的API**

   | 方法名称                                             | 说明                         |
   | ---------------------------------------------------- | ---------------------------- |
   | public void write(int a)                             | 写一个字节出去               |
   | public void write(byte[] buffer)                     | 写一个字节数组出去           |
   | public void write(byte[] buffer , int pos , int len) | 写一个字节数组的一部分出去。 |

   **流的关闭与刷新**

   | 方法    | 说明                                                         |
   | ------- | ------------------------------------------------------------ |
   | flush() | 刷新流，还可以继续写数据                                     |
   | close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |

   1. **字节输出流如何实现数据追加更多操作**

      public FileOutputStream(String filepath，boolean append)

      创建字节输出流管道与源文件路径接通，可追加数据

   2. **字节输出流如何实现写出去的数据能换行**
      - os.write(“\r\n”.getBytes())

   3. **如何让写出去的数据能成功生效？**
      - flush()刷新数据
      - close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。

2. 文件拷贝

   ![文件字节复制流程](D:\桌面文件\笔记\notes\java-base\image\copy_byte_process.png)

   **需求：**

   - 把某个视频复制到其他目录下的“b.avi”

   **思路：**

   1. 根据数据源创建字节输入流对象
   2. 根据目的地创建字节输出流对象
   3. 读写数据，复制视频
   4. 释放资源

   

   **字节流适合做一切文件数据的拷贝吗？**
   任何文件的底层都是字节，拷贝是一字不漏的转移字节，只要前后文件格式、编码一致没有任何问题。



# 资源释放的方式

## try-catch-finally

- finally：在异常处理时提供finally块来执行所有清除操作，比如说IO流中的释放资源
- 特点：被finally控制的语句最终**一定会执行，除非JVM退出**( 即System.exit(0);)
- 异常处理标准格式：try….catch…finally

**try-catch-finally格式**

```
try {
	FileOutputStream fos = new FileOutputStream("a.txt");
	fos.write(97); 
} catch (IOException e) {
	e.printStackTrace();
}finally{

}
```

## try-with-resource

1. finally虽然可以用于释放资源，但是释放资源的代码过于繁琐？

2. 有没有办法简化？

   ```
   InputStream is = null ;
   OutputStream os = null;
   try{
   	...
   }catch (Exception e){
   	e.printStackTrace();
   } finally {
       // 关闭资源！
       try {
       	if(os != null) os.close();
       } catch (Exception e) {
       	e.printStackTrace();
       }
       try {
       	if(is != null) is.close();
       } catch (Exception e) {
       	e.printStackTrace();
       }
   }
   
   ```

**JDK 7和JDK9中都简化了资源释放操作**

**基本做法**：手动释放资源

```
try{
	可能出现异常的代码;
}catch(异常类名 变量名){
	异常的处理代码;
}finally{
	执行所有资源释放操作;
}
```

**JDK7改进方案**： 资源用完最终自动释放

```
try(定义流对象){
	可能出现异常的代码;
}catch(异常类名 变量名){
	异常的处理代码;
} 
```

**JDK9改进方案：**资源用完最终自动释放

```
定义输入流对象;
定义输出流对象;
try(输入流对象；输出流对象){
	可能出现异常的代码;
}catch(异常类名 变量名){
	异常的处理代码;
}
```

**注意**

- JDK 7 以及 JDK 9的()中只能放置资源对象，否则报错
- 什么是资源呢？
- 资源都是实现了Closeable/AutoCloseable接口的类对象

`public abstract class InputStream implements Closeable {}`

`public abstract class OutputStream implements Closeable, Flushable{}`

**需求：**

- 将某个磁盘的文件夹拷贝到另一个文件夹下去，包括文件夹中的全部信息

**分析：**

1. IO默认不可以拷贝文件夹
2. 我们需要遍历文件夹，如果是文件则拷贝过去，如果是文件夹则要进行1-1创建，继续复制内容。



# 字符流的使用

1. 字节流读取中文输出会存在什么问题？
   - 会乱码。或者内存溢出。

2. 读取中文输出，哪个流更合适，为什么？
   - 字符流更合适，最小单位是按照单个字符读取的。

## 文件字符输入流

1. 一次读取一个字符

   文件字符输入流：Reader

   作用：以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。

   | 构造器                             | 说明                               |
   | ---------------------------------- | ---------------------------------- |
   | public FileReader(File file)       | 创建字符输入流管道与源文件对象接通 |
   | public FileReader(String pathname) | 创建字符输入流管道与源文件路径接通 |

   | 方法名称                       | 说明                                                         |
   | ------------------------------ | ------------------------------------------------------------ |
   | public int read()              | 每次读取一个字符返回，如果字符已经没有可读的返回-1           |
   | public int read(char[] buffer) | 每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1 |

   **字符流的好处。每次读取一个字符存在什么问题？**

   - 读取中文字符不会出现乱码（如果代码文件编码一致）
   - 性能较慢



2. 一次读取一个字符数组

   文件字符输入流：FileReader

   作用：以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。

   | 方法名称                       | 说明                                                         |
   | ------------------------------ | ------------------------------------------------------------ |
   | public int read()              | 每次读取一个字符返回，如果字符已经没有可读的返回-1           |
   | public int read(char[] buffer) | 每次读取一个字符数组，返回读取的字符数，如果字符已经没有可读的返回-1 |

   **每次读取一个字符数组的优势？**

   - 读取的性能得到了提升
   - 读取中文字符输出不会乱码。



## 文件字符输出流

文件字符输出流：FileWriter

作用：以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。

| 构造器                                             | 说明                                           |
| -------------------------------------------------- | ---------------------------------------------- |
| public FileWriter(File file)                       | 创建字符输出流管道与源文件对象接通             |
| public FileWriter(File file，boolean append)       | 创建字符输出流管道与源文件对象接通，可追加数据 |
| public FileWriter(String filepath)                 | 创建字符输出流管道与源文件路径接通             |
| public FileWriter(String filepath，boolean append) | 创建字符输出流管道与源文件路径接通，可追加数据 |

**文件字符输出流（FileWriter）写数据出去的API**

| 方法名称                                  | 说明                 |
| ----------------------------------------- | -------------------- |
| void write(int c)                         | 写一个字符           |
| void write(char[] cbuf)                   | 写入一个字符数组     |
| void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |
| void write(String str)                    | 写一个字符串         |
| void write(String str, int off, int len)  | 写一个字符串的一部分 |
| void write(int c)                         | 写一个字符           |

**流的关闭与刷新** 

| 方法    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| flush() | 刷新流，还可以继续写数据                                     |
| close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |

1. 字符输出流如何实现数据追加更多操作

   `public FileWriter(String filepath，boolean append)`

   创建字符输出流管道与源文件路径接通，可追加数据

2. 字符输出流如何实现写出去的数据能换行

   - fw.write(“\r\n”)

3.  字符输出流如何实现写出去的数据能换行

   - flush()刷新数据

   - close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。

4.  字节流、字符流如何选择使用？
   - 字节流适合做一切文件数据的拷贝（音视频，文本）
   - 字节流不适合读取中文内容输出
   - 字符流适合做文本文件的操作（读，写）
